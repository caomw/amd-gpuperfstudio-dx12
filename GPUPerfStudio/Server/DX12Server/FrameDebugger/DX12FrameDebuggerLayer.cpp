//==============================================================================
/// Copyright (c) 2015 Advanced Micro Devices, Inc. All rights reserved.
/// \author AMD Developer Tools Team
/// \file DX12FrameDebuggerLayer.cpp
/// \brief The DX12FrameDebuggerLayer is responsible for operations related to
/// inspecting individual frames of an instrumented D3D12 application.
//==============================================================================

#include "DX12FrameDebuggerLayer.h"
#include "../Rendering/DX12ImageRenderer.h"
#include "../Objects/Autogenerated/DX12CoreWrappers.h"
#include "../Common/SaveImage.h"
#include "../Common/ErrorImage.h"

// @TODO: Remove this soon. It's for debugging only.
#define BACKBUFFER_CAPTURE_TESTCODE
#ifdef BACKBUFFER_CAPTURE_TESTCODE
    #include "../DX12LayerManager.h"
#endif

//--------------------------------------------------------------------------
/// Default constructor for DX12FrameDebuggerLayer.
//--------------------------------------------------------------------------
DX12FrameDebuggerLayer::DX12FrameDebuggerLayer()
: mLastPresentedSwapchain(NULL)
{
    AddCommand(CONTENT_PNG, "GetBackBufferImage", "GetBackBufferImage", "GetBackBufferImage.png", NO_DISPLAY, NO_INCLUDE, mGetBackBufferImage);
}

//--------------------------------------------------------------------------
/// Default destructor for DX12FrameDebuggerLayer.
//--------------------------------------------------------------------------
DX12FrameDebuggerLayer::~DX12FrameDebuggerLayer()
{
}

//--------------------------------------------------------------------------
/// Called at the end of a frame
//--------------------------------------------------------------------------
void DX12FrameDebuggerLayer::EndFrame()
{
    if (mGetBackBufferImage.IsActive())
    {
        HandleBackBufferRequest(mGetBackBufferImage);
    }

#ifdef BACKBUFFER_CAPTURE_TESTCODE
    // @TODO: This is debugging code that makes testing convenient, but should be removed when backbuffer capture is well-tested.
    bool bCaptureKeyPressed = (GetKeyState('F') & 0x8000) != 0;
    if (bCaptureKeyPressed)
    {
        unsigned char* imageData = NULL;
        unsigned int numBytes = 0;
        bool bCaptureSuccessful = CaptureBackBuffer(1280, 720, &imageData, &numBytes);
        if (bCaptureSuccessful)
        {
            // Construct a decent filename to write the image out to for testing.
            int frameIndex = GetDX12LayerManager()->GetFrameCount();
            gtASCIIString frameFilename;
            frameFilename.appendFormattedString("C:\\TEMP\\backBufferImage_%d.png", frameIndex);

            FILE* pngFile = fopen(frameFilename.asCharArray(), "wb");
            if (pngFile != NULL)
            {
                fwrite(imageData, sizeof(unsigned char), numBytes, pngFile);
                fclose(pngFile);
            }
        }
    }
#endif
}

//--------------------------------------------------------------------------
/// Gets called after a frame has been presented.
/// \param inSwapchain The swapchain instance used to present to the screen.
//--------------------------------------------------------------------------
void DX12FrameDebuggerLayer::OnPresent(void* inSwapchain)
{
    mLastPresentedSwapchain = static_cast<IDXGISwapChain*>(inSwapchain);
}

//--------------------------------------------------------------------------
/// Handler invoked when a new Swapchain is created.
/// \param inSwapchain The swapchain instance that was just created.
/// \param inDevice The CommandQueue used to create the swapchain.
//--------------------------------------------------------------------------
void DX12FrameDebuggerLayer::OnSwapchainCreated(void* inSwapchain, void* inDevice)
{
    IDXGISwapChain* newSwapchain = static_cast<IDXGISwapChain*>(inSwapchain);
    if (mSwapchainToCommandQueue.find(newSwapchain) == mSwapchainToCommandQueue.end())
    {
        // Associate the swapchain with a commandqueue.
        mSwapchainToCommandQueue[newSwapchain] = static_cast<ID3D12CommandQueue*>(inDevice);
    }
}

//--------------------------------------------------------------------------
/// Capture the current backbuffer image, and return an byte array of PNG-encoded image data.
/// Note that the output "ioBackBufferPngData" array must be deleted when finished, or else it will leak.
/// \param inWidth The requested width of the captured backbuffer image.
/// \param inHeight The requested height of the captured backbuffer image.
/// \param ioBackBufferPngData A pointer to the byte array of PNG-encoded image data.
/// \param outNumBytes The total number of bytes in the array of encoded image data.
/// \returns True if the back buffer image was captured successfully. False if it failed.
//--------------------------------------------------------------------------
bool DX12FrameDebuggerLayer::CaptureBackBuffer(unsigned int inWidth, unsigned int inHeight, unsigned char** ioBackBufferPngData, unsigned int* outNumBytes)
{
    bool bCaptureSuccessful = false;

    if (mLastPresentedSwapchain != NULL)
    {
        ID3D12Resource* backBufferResource = NULL;
        HRESULT gotBackBuffer = mLastPresentedSwapchain->GetBuffer(0, __uuidof(ID3D12Resource), (void**)&backBufferResource);

        if (gotBackBuffer == S_OK)
        {
            // Attempt to find the CommandQueue used to create the active swapchain.
            SwapchainToQueueMap::iterator swapchainQueueIter = mSwapchainToCommandQueue.find(mLastPresentedSwapchain);
            if (swapchainQueueIter != mSwapchainToCommandQueue.end())
            {
                ID3D12CommandQueue* commandQueue = swapchainQueueIter->second;
                ID3D12CommandQueue* queuePtr = static_cast<GPS_ID3D12CommandQueue*>(commandQueue)->mRealCommandQueue;

                ID3D12Device* parentDevice = NULL;
                HRESULT gotDevice = queuePtr->GetDevice(__uuidof(ID3D12Device), (void**)&parentDevice);

                if (gotDevice == S_OK)
                {
                    DX12ImageRendererConfig rendererConfig;
                    rendererConfig.pCmdQueue = queuePtr;
                    rendererConfig.pDevice = parentDevice;

                    DX12ImageRenderer* backBufferRenderer = backBufferRenderer->Create(rendererConfig);

                    if (backBufferRenderer != NULL)
                    {
                        CpuImage capturedImage;
                        HRESULT captureResult = backBufferRenderer->CaptureImage(backBufferResource, D3D12_RESOURCE_STATE_PRESENT, inWidth, inHeight, &capturedImage, false, false);

                        if (captureResult == S_OK)
                        {
                            // Convert the captured image's pixel data into a PNG byte array.
                            bCaptureSuccessful = DX12ImageRenderer::CpuImageToPng(&capturedImage, ioBackBufferPngData, outNumBytes);
                        }
                        else
                        {
                            Log(logERROR, "Failed to capture back buffer image.\n");
                        }

                        // Destroy the image renderer.
                        SAFE_DELETE(backBufferRenderer);
                    }
                    else
                    {
                        Log(logERROR, "Failed to create a DX12ImageRenderer for backbuffer capture.\n");
                    }
                }
                else
                {
                    Log(logERROR, "Failed to retrieve parent device from swapchain buffer.\n");
                }
            }
            else
            {
                Log(logERROR, "Failed to retrieve CommandQueue used to create presentation Swapchain.\n");
            }
        }
        else
        {
            Log(logERROR, "Failed to retrieve backbuffer from swapchain.\n");
        }
    }
    else
    {
        Log(logERROR, "Failed to capture Back Buffer: No active Swapchain set in Frame Debugger.\n");
    }

    return bCaptureSuccessful;
}

//--------------------------------------------------------------------------
/// Handle an incoming image request by sending the image data as a response.
/// \param inImageCommand The command used to request image data.
/// \returns True when the backbuffer was suceessfully captured and sent back as a response.
//--------------------------------------------------------------------------
bool DX12FrameDebuggerLayer::HandleBackBufferRequest(PictureCommandResponse& inImageCommand)
{
    unsigned int imageWidth = inImageCommand.GetWidth();
    unsigned int imageHeight = inImageCommand.GetHeight();
    unsigned char* backBufferImageData = NULL;
    unsigned int numImageBytes = 0;

    bool bCaptureSuccessful = CaptureBackBuffer(imageWidth, imageHeight, &backBufferImageData, &numImageBytes);
    if (bCaptureSuccessful)
    {
        // Send the image back as a chunk of response data.
        inImageCommand.Send(reinterpret_cast<const char*>(backBufferImageData), numImageBytes);

        // Free the image data after we're done using it, and destroy the image renderer.
        SAFE_DELETE_ARRAY(backBufferImageData);
    }
    else
    {
        // Send the error image if capturing failed.
        ErrorImage::Instance()->Send(&mGetBackBufferImage);

        Log(logERROR, "Failed to capture Back Buffer. Replying with error image.\n");
    }

    return bCaptureSuccessful;
}