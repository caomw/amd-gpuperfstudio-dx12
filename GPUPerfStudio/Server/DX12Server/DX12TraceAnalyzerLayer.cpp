//==============================================================================
// Copyright (c) 2015 Advanced Micro Devices, Inc. All rights reserved.
/// \author AMD Developer Tools Team
/// \file
/// \brief  The DX12 TraceAnalyzer layer that manages API and GPU trace collection and response.
//==============================================================================

// A magic number that indicates a "session not started" state for GPA.
#define INVALID_SESSION_ID 0x1337

#include "DX12TraceAnalyzerLayer.h"
#include "DX12LayerManager.h"
#include "DX12Defines.h"
#include "Interception/DX12Interceptor.h"
#include "Objects/IDX12InstanceBase.h"
#include "Objects/DX12ObjectDatabaseProcessor.h"
#include "Objects/DX12WrappedObjectDatabase.h"
#include "Objects/Autogenerated/DX12CoreWrappers.h"
#include "Util/DX12Utilities.h"
#include "DX12Defines.h"

//--------------------------------------------------------------------------
/// Retrieve the API name string for a DX12APIEntry instance.
/// \returns A null-terminated string containing the API name.
//--------------------------------------------------------------------------
const char* DX12APIEntry::GetAPIName() const
{
    return DX12TraceAnalyzerLayer::Instance()->GetFunctionNameFromId(this->mFunctionId);
}

//--------------------------------------------------------------------------
/// Write a DX12-specific APITrace response line into the incoming string stream.
/// \param ioTraceResponse The stringstream instance that each trace response line is written to.
/// \param inStartTime The start time for the API call.
/// \param inEndTime The end time for the API call.
//--------------------------------------------------------------------------
void DX12APIEntry::AppendAPITraceLine(std::stringstream& ioTraceResponse, double inStartTime, double inEndTime) const
{
    gtASCIIString returnValueString;
    DX12Util::PrintReturnValue(mReturnValue, returnValueString);

    // Use the database processor to get a pointer to the object database.
    DX12ObjectDatabaseProcessor* databaseProcessor = DX12ObjectDatabaseProcessor::Instance();
    DX12WrappedObjectDatabase* objectDatabase = static_cast<DX12WrappedObjectDatabase*>(databaseProcessor->GetObjectDatabase());

    // Use the object database to retrieve wrapper info for the given interface.
    IDX12InstanceBase* wrapperInfo = objectDatabase->GetMetadataObject(mWrapperInterface);

#if defined(CODEXL_GRAPHICS)
    // Below is an API Trace response that "CodeXL Graphics" understands how to parse.

    // APIType APIFunctionId InterfacePtr D3D12Interface_FunctionName(Parameters) = ReturnValue StartMillisecond EndMillisecond SampleId
    ioTraceResponse
            << DX12TraceAnalyzerLayer::Instance()->GetAPIGroupFromAPI(mFunctionId) << " "
            << mFunctionId << " "
            << "0x" << wrapperInfo->GetApplicationHandle() << " "
            << wrapperInfo->GetTypeAsString() << "_"
            << GetAPIName()
            << "(" << mParameters.asCharArray() << ") = "
            << returnValueString.asCharArray()
            << " " << std::fixed << inStartTime    // We don't want this number to get converted to scientific noation. Used std::fixed.
            << " " << std::fixed << inEndTime
            << " " << mSampleId
            << std::endl;  // Finish the string with a newline to play nice with the next logged call.
#else
    // Below is an API Trace response that GPUPerfStudio understands how to parse.

    // Each logged call follows a specific format as it's inserted into a response string. This format is mirrored in client code:
    // ThreadId Interface_FunctionName(Parameters) = ReturnValue StartTime EndTime SampleId
    ioTraceResponse
            << mThreadId << " "
            << "0x" << wrapperInfo->GetApplicationHandle() << " "
            << wrapperInfo->GetTypeAsString() << "_"
            << GetAPIName()
            << "(" << mParameters.asCharArray() << ") = "
            << returnValueString.asCharArray()
            << " " << std::fixed << inStartTime    // We don't want this number to get converted to scientific noation. Used std::fixed.
            << " " << std::fixed << inEndTime
            << " " << mSampleId
            << std::endl;  // Finish the string with a newline to play nice with the next logged call.
#endif
}

//--------------------------------------------------------------------------
/// Check if this logged APIEntry is a Draw call.
/// \returns True if the API is a draw call. False if it's not.
//--------------------------------------------------------------------------
bool DX12APIEntry::IsDrawCall() const
{
    return DX12TraceAnalyzerLayer::Instance()->ShouldProfileFunction(mFunctionId);
}

//--------------------------------------------------------------------------
/// Protected constructor, because this is a singleton.
//--------------------------------------------------------------------------
DX12TraceAnalyzerLayer::DX12TraceAnalyzerLayer()
    : MultithreadedTraceAnalyzerLayer()
    , mCurrentSessionId(INVALID_SESSION_ID)
{
    SetProfiledFuncs();
}

//--------------------------------------------------------------------------
/// DX12TraceAnalyzerLayer destructor. Cleans up DX12-specific trace data.
//--------------------------------------------------------------------------
DX12TraceAnalyzerLayer::~DX12TraceAnalyzerLayer()
{
}

//--------------------------------------------------------------------------
/// Retrieve a pointer to the parent LayerManager used by this tool.
/// \returns A pointer to the parent LayerManager used by this tool.
//--------------------------------------------------------------------------
//ModernAPILayerManager* DX12TraceAnalyzerLayer::GetParentLayerManager()
//{
//    DX12LayerManager* dx12LayerManager = DX12LayerManager::Instance();
//    return dx12LayerManager;
//}

//--------------------------------------------------------------------------
/// Find the CommandQueue associated with a profiled DX12APIEntry instance.
/// \param inEntry The DX12 API Entry structure to find a CommandQueue for.
/// \returns The CommandQueue associated with the execution of the given API Entry.
//--------------------------------------------------------------------------
GPS_ID3D12CommandQueue* DX12TraceAnalyzerLayer::FindCommandQueueForAPIEntry(DX12APIEntry* inEntry)
{
    GPS_ID3D12CommandQueue* commandQueue = NULL;

    ScopeLock queueTrackerLock(&mCommandQueueLockMutex);
    CommandQueueToCommandListMap::iterator queueMapIter;

    for (queueMapIter = mCommandQueueTracker.begin(); queueMapIter != mCommandQueueTracker.end(); ++queueMapIter)
    {
        WrappedCommandListSet& commandListSet = queueMapIter->second;
        WrappedCommandListSet::iterator setIter;

        for (setIter = commandListSet.begin(); setIter != commandListSet.end(); ++setIter)
        {
            GPS_ID3D12GraphicsCommandList* cmdList = static_cast<GPS_ID3D12GraphicsCommandList*>(*setIter);

            if (cmdList == inEntry->mWrapperInterface)
            {
                commandQueue = queueMapIter->first;
            }
        }
    }

    return commandQueue;
}

//--------------------------------------------------------------------------
/// Retrieve the type of CommandList when given the Queue that executed it.
/// \param inQueue A CommandQueue to retrieve the command list type for.
/// \returns The type of CommandList utilized by the given queue.
//--------------------------------------------------------------------------
D3D12_COMMAND_LIST_TYPE DX12TraceAnalyzerLayer::GetCommandListTypeFromCommandQueue(GPS_ID3D12CommandQueue* inQueue)
{
    // Use the metadata object to retrieve the cached CreateInfo, and then pull the type out. Start with "Direct".
    D3D12_COMMAND_LIST_TYPE commandListType = D3D12_COMMAND_LIST_TYPE_DIRECT;

    PsAssert(inQueue != NULL);
    if (inQueue != NULL)
    {
        DX12ObjectDatabaseProcessor* databaseProcessor = DX12ObjectDatabaseProcessor::Instance();
        DX12WrappedObjectDatabase* objectDatabase = static_cast<DX12WrappedObjectDatabase*>(databaseProcessor->GetObjectDatabase());

        IDX12InstanceBase* queueMetadata = objectDatabase->GetMetadataObject((IUnknown*)inQueue);
        GPS_ID3D12CommandQueueCreateInfo* queueCreateInfo = static_cast<GPS_ID3D12CommandQueueCreateInfo*>(queueMetadata->GetCreateInfoStruct());
        D3D12_COMMAND_QUEUE_DESC* queueDesc = queueCreateInfo->GetDescription();
        commandListType = queueDesc->Type;
    }

    return commandListType;
}

//--------------------------------------------------------------------------
/// Provides a chance to initialize states before a GPU trace is performed.
//--------------------------------------------------------------------------
void DX12TraceAnalyzerLayer::BeforeGPUTrace()
{
    DX12Interceptor* dx12Interceptor = static_cast<DX12Interceptor*>(GetInterceptor());
    dx12Interceptor->ResetSampleIdCounter();

    // Clear out the map that associates SampleId to APIEntries.
    mSampleIdToEntry.clear();
    mCommandListToSampleId.clear();
}

//--------------------------------------------------------------------------
/// Get the Profiler Results for the specified command lists
/// \param numCommandLists the number of command lists contained in ppCommandLists
/// \prarm ppCommandLists the set of command lists to get the profiler results from
//--------------------------------------------------------------------------
void DX12TraceAnalyzerLayer::GetProfileResultsForCmdLists(UINT numCommandLists, ID3D12CommandList* const* ppCommandLists)
{
    DX12Interceptor* dx12Interceptor = static_cast<DX12Interceptor*>(GetInterceptor());

    if (dx12Interceptor->ShouldCollectGPUTime())
    {
        dx12Interceptor->LockGPA();
		GPUPerfAPILoader& gpaLoader = dx12Interceptor->GetGPALoader();

        for (UINT i = 0; i < numCommandLists; i++)
        {
            GPS_ID3D12GraphicsCommandList* const* cmdLists = reinterpret_cast<GPS_ID3D12GraphicsCommandList* const*>(ppCommandLists);
            ID3D12GraphicsCommandList* pRealGraphicsCommandList = cmdLists[i]->mRealGraphicsCommandList;
            if (nullptr == pRealGraphicsCommandList)
            {
                Log(logWARNING, "Executing an unknown (non-wrapped) command list\n");
            }
            else
            {
                dx12Interceptor->SwitchGPAContext(pRealGraphicsCommandList);

                GPA_Status endPassStatus = gpaLoader.GPA_EndPass();

                if (GPA_STATUS_OK != endPassStatus)
                {
                    Log(logERROR, "Failed to end GPA pass. Error code: '%d'.\n", endPassStatus);
                }
                else
                {
                    GPA_Status endSessionStatus = gpaLoader.GPA_EndSession();

                    if (GPA_STATUS_OK != endSessionStatus)
                    {
                        Log(logERROR, "Failed to end GPA session '%d'. Error code: '%d'.\n", mCurrentSessionId, endSessionStatus);
                    }
                    else
                    {
                        gpa_uint32 enabledCount;
                        GPA_Status gpaStatus = gpaLoader.GPA_GetEnabledCount(&enabledCount);

                        if (gpaStatus == GPA_STATUS_OK && 0 < enabledCount)
                        {
                            gpa_uint32 numSamples = 0;
                            GPA_Status getCountStatus = gpaLoader.GPA_GetSampleCount(mCurrentSessionId, &numSamples);

                            if (getCountStatus == GPA_STATUS_OK)
                            {
                                bool isReady = false;
                                gpaLoader.GPA_IsSessionReady(&isReady, mCurrentSessionId);

                                if (isReady)
                                {
                                    if (mCommandListToSampleId.count(pRealGraphicsCommandList) > 0)
                                    {
                                        std::vector<gpa_uint32> samplesForCommandList = mCommandListToSampleId[pRealGraphicsCommandList];

                                        // Step through each APIEntry that has an associated sample ID, and retrieve the profiler result.
                                        for (std::vector<gpa_uint32>::iterator sampleIter = samplesForCommandList.begin(); sampleIter != samplesForCommandList.end(); ++sampleIter)
                                        {
                                            DX12APIEntry* entry = mSampleIdToEntry[*sampleIter]; //sampleIdIter->second;

                                            gpa_uint32 preBottomCounterIndex = 0;
                                            gpa_uint32 postBottomCounterIndex = 0;
                                            GPA_Status counterPreIndexStatus = gpaLoader.GPA_GetCounterIndex("PreBottomTimestamp", &preBottomCounterIndex);
                                            GPA_Status counterPostIndexStatus = gpaLoader.GPA_GetCounterIndex("PostBottomTimestamp", &postBottomCounterIndex);

                                            if (counterPreIndexStatus == GPA_STATUS_OK && counterPostIndexStatus == GPA_STATUS_OK)
                                            {
                                                GPA_Status preBottomStatus = gpaLoader.GPA_GetSampleFloat64(mCurrentSessionId, entry->mSampleId, preBottomCounterIndex, &entry->preBottomTimestamp);
                                                GPA_Status postBottomStatus = gpaLoader.GPA_GetSampleFloat64(mCurrentSessionId, entry->mSampleId, postBottomCounterIndex, &entry->postBottomTimestamp);

                                                if (GPA_STATUS_OK != preBottomStatus || GPA_STATUS_OK != postBottomStatus)
                                                {
                                                    Log(logERROR, "Unable to retireve timestamp counters from GPA");
                                                }
                                            }
                                        }
                                    }

                                    mCurrentSessionId = INVALID_SESSION_ID;
                                    gpaLoader.GPA_CloseContext();
                                    OpenAndInitializeGPAContext(pRealGraphicsCommandList);
                                }
                            }
                        }
                    }
                }
            }
        }

        dx12Interceptor->UnlockGPA();
    }
}

//-----------------------------------------------------------------------------
/// Return GPU-time in text format, to be parsed by the Client and displayed as its own timeline.
/// \return A line-delimited, ASCII-encoded, version of the GPU Trace data.
//-----------------------------------------------------------------------------
std::string DX12TraceAnalyzerLayer::GetGPUTraceTXT()
{
    std::stringstream gpuTraceResponseStream;

#if USE_GPA_PROFILING
    bool bWriteResponseString = false;

    {

        // Insert the correct trace preamble based on how it will be used.
#if defined(CODEXL_GRAPHICS)
        gpuTraceResponseStream << "//==GPU Trace==" << std::endl;
        gpuTraceResponseStream << "//CommandListEventCount=" << mSampleIdToEntry.size() << std::endl;
#endif

        SampleIdToAPIEntryMap::iterator sampleIdIter;
        SampleIdToAPIEntryMap::iterator mapEnd = mSampleIdToEntry.end();

        // Step through each APIEntry that has an associated sample ID, and retrieve the profiler result.
        for (sampleIdIter = mSampleIdToEntry.begin(); sampleIdIter != mapEnd; ++sampleIdIter)
        {
            DX12APIEntry* entry = sampleIdIter->second;

            GPS_ID3D12CommandQueue* entryQueue = FindCommandQueueForAPIEntry(entry);

            // At this point we must have the associated Queue that executed the profiled commands.
            PsAssert(entryQueue != NULL);

            D3D12_COMMAND_LIST_TYPE commandListType = GetCommandListTypeFromCommandQueue(entryQueue);

            // The only thing that can be profiled is an GPS_ID3D12GraphicsCommandList.
            GPS_ID3D12GraphicsCommandList* commandList = reinterpret_cast<GPS_ID3D12GraphicsCommandList*>(entry->mWrapperInterface);


            gtASCIIString returnValueString;
            DX12Util::PrintReturnValue(entry->mReturnValue, returnValueString);

            // Convert the functionID and return values from integers into full strings that we can use in the response.
            const char* functionName = GetFunctionNameFromId(entry->mFunctionId);
            const char* parameters = entry->mParameters.asCharArray();

            // If we're using the new response format, we write each line a little differently.
#if defined(CODEXL_GRAPHICS)
            // DX12 Response line format:
            // CommandQueuePtr CommandListType CommandListPtr APIType FuncId ID3D12InterfaceName_FuncName(Args) = ReturnValue StartTime EndTime SampleId
            gpuTraceResponseStream
                << "0x" << entryQueue << " "
                    << commandListType << " "
                    << "0x" << commandList << " "
                    << GetAPIGroupFromAPI(entry->mFunctionId) << " "
                    << entry->mFunctionId << " "
                    << "ID3D12GraphicsCommandList_" << functionName
                    << "(" << parameters << ") = "
                    << returnValueString.asCharArray() << " "
                    << std::fixed << entry->preBottomTimestamp << " "
                    << std::fixed << entry->postBottomTimestamp << " "
                    << entry->mSampleId
                    << std::endl;
#else
            // DX12 Response line format:
            // QueuePtr CommandListType CommandListPtr ID3D12InterfaceName_FuncName(Args) = ReturnValue StartTime EndTime SampleId
            gpuTraceResponseStream
                << entryQueue << " "
                    << commandListType << " "
                    << commandList << " "
                    << "ID3D12GraphicsCommandList_" << functionName
                    << "(" << parameters << ") = "
                    << returnValueString.asCharArray() << " "
                    << std::fixed << entry->preBottomTimestamp << " "
                    << std::fixed << entry->postBottomTimestamp << " "
                    << entry->mSampleId
                    << std::endl;
#endif

            // We've appended a legitimate line into the response. It should be safe to return it to the client.
            bWriteResponseString = true;
        }
    }

    // If we failed to write any actual trace information to the response, return a known failure string so the client can respond appropriately.
    if (!bWriteResponseString)
    {
        gpuTraceResponseStream << "NODATA";
    }

#else

    // During QueueSubmit we stored ProfilerResults in mEntriesWithProfilingResults. Form a response using it here.
    if (!mEntriesWithProfilingResults.empty())
    {
        size_t numSamples = 0;
        QueueWrapperToProfilingResultsMap::const_iterator queuesWithProfilingResults;

        // Compute how many results we should expect to write.
        QueueWrapperToProfilingResultsMap::iterator queueResultsIter;
        for (queueResultsIter = mEntriesWithProfilingResults.begin(); queueResultsIter != mEntriesWithProfilingResults.end(); ++queueResultsIter)
        {
            SampleIdToProfilerResultMap* resultsMap = queueResultsIter->second;
            numSamples += resultsMap->size();
        }

        // Insert the correct trace preamble based on how it will be used.
#if defined(CODEXL_GRAPHICS)
        gpuTraceResponseStream << "//==GPU Trace==" << std::endl;
        gpuTraceResponseStream << "//CommandListEventCount=" << numSamples << std::endl;
#endif

        for (queuesWithProfilingResults = mEntriesWithProfilingResults.begin(); queuesWithProfilingResults != mEntriesWithProfilingResults.end(); ++queuesWithProfilingResults)
        {
            GPS_ID3D12CommandQueue* pWrappedQueue = queuesWithProfilingResults->first;

            UINT64 timestampFrequency = 0;
            pWrappedQueue->mRealCommandQueue->GetTimestampFrequency(&timestampFrequency);

            // This structure holds all of the profiler results that were collected at QueueSubmit. The form is LinkId->ProfilerResult.
            const SampleIdToProfilerResultMap* pQueueResults = queuesWithProfilingResults->second;

            SampleIdToProfilerResultMap::const_iterator queueResultsIterInner;

            for (queueResultsIterInner = pQueueResults->begin(); queueResultsIterInner != pQueueResults->end(); ++queueResultsIterInner)
            {
                UINT64 sampleId = queueResultsIterInner->first;
                const ProfilerResult* pResult = queueResultsIterInner->second;

                DX12APIEntry* pResultEntry = FindInvocationBySampleId(sampleId);

                // Convert the functionID and return values from integers into full strings that we can use in the response.
                const char* pFunctionName = GetFunctionNameFromId(pResultEntry->mFunctionId);
                const char* pParameters = pResultEntry->mParameters.asCharArray();

                gtASCIIString returnValueString;
                DX12Util::PrintReturnValue(pResultEntry->mReturnValue, returnValueString);

                double startMillisecond = ((double)pResult->timestampResult.rawClocks.start / (double)timestampFrequency) * 1000.0;
                double endMillisecond = ((double)pResult->timestampResult.rawClocks.end / (double)timestampFrequency) * 1000.0;

                D3D12_COMMAND_LIST_TYPE commandListType = GetCommandListTypeFromCommandQueue(pWrappedQueue);

#if defined(CODEXL_GRAPHICS)

                // The only thing that can be profiled is an GPS_ID3D12GraphicsCommandList.
                GPS_ID3D12GraphicsCommandList* commandList = reinterpret_cast<GPS_ID3D12GraphicsCommandList*>(pResultEntry->mWrapperInterface);

                // DX12 Response line format:
                // CommandQueuePtr CommandListType CommandListPtr APIType FuncId ID3D12InterfaceName_FuncName(Args) = ReturnValue StartTime EndTime SampleId
                gpuTraceResponseStream
                    << "0x" << pWrappedQueue << " "
                    << commandListType << " "
                    << "0x" << commandList << " "
                    << GetAPIGroupFromAPI(pResultEntry->mFunctionId) << " "
                    << pResultEntry->mFunctionId << " "
                    << "ID3D12GraphicsCommandList_" << pFunctionName
                    << "(" << pParameters << ") = "
                    << returnValueString.asCharArray() << " "
                    << std::fixed << startMillisecond << " "
                    << std::fixed << endMillisecond << " "
                    << pResultEntry->mSampleId
                    << std::endl;
#else
                gpuTraceResponseStream
                    << pWrappedQueue << " "
                    << commandListType << " "
                    << pResult->measurementInfo.idInfo.pCmdList << " "
                    << "ID3D12GraphicsCommandList_" << pFunctionName
                    << "(" << pParameters << ") = "
                    << returnValueString.asCharArray() << " "
                    << std::fixed << startMillisecond << " "
                    << std::fixed << endMillisecond << " "
                    << pResultEntry->mSampleId
                    << std::endl;
#endif
            }
        }
    }
    else
    {
        gpuTraceResponseStream << "NODATA";
    }

#endif

    return gpuTraceResponseStream.str();
}

//--------------------------------------------------------------------------
/// Insert an APIEntry into the list of entries with profiler results.
/// \param inEntry An APIEntry with a sampled GPU time.
//--------------------------------------------------------------------------
void DX12TraceAnalyzerLayer::StoreProfilerResult(DX12APIEntry* inEntry)
{
    mSampleIdToEntry[inEntry->mSampleId] = inEntry;
}

//--------------------------------------------------------------------------
/// Create a new ThreadTraceData instance for use specifically with DX12 APIs.
/// \returns A new ThreadTraceData instance to trace DX12 API calls.
//--------------------------------------------------------------------------
ThreadTraceData* DX12TraceAnalyzerLayer::CreateThreadTraceDataInstance()
{
    return new DX12ThreadTraceData();
}

//--------------------------------------------------------------------------
/// Retrieve the interceptor instance responsible for managing tracing in this API.
/// \returns The InterceptorBase that's used to control tracing for this API.
//--------------------------------------------------------------------------
InterceptorBase* DX12TraceAnalyzerLayer::GetInterceptor()
{
    return GetDX12LayerManager()->GetInterceptor();
}

//--------------------------------------------------------------------------
/// Log a DX12 API call within the Trace Analyzer.
/// \param inInterface The interface wrapper being used to invoke the API call.
/// \param inFunctionId The FuncId for the API function that's being logged.
/// \param inArguments The stringified API call arguments for the function that's being logged.
/// \param inReturnValue The return value for the API call, or FUNCTION_RETURNS_VOID if there is none.
/// \returns The newly-created DX12APIEntry instance used to track the info for this API call.
//--------------------------------------------------------------------------
DX12APIEntry* DX12TraceAnalyzerLayer::LogAPICall(IUnknown* inWrappedInterface, FuncId inFunctionId, const char* inArguments, INT64 inReturnValue)
{
    ScopeLock logAPICallLock(&mTraceMutex);

    (void)inReturnValue;

    DWORD threadId = osGetCurrentThreadId();
    ThreadTraceData* currentThreadData = FindOrCreateThreadData(threadId);

    if (currentThreadData->m_startTime.QuadPart == s_DummyTimestampValue)
    {
        const char* functionNameString = GetFunctionNameFromId(inFunctionId);
        Log(logERROR, "There was a problem setting the start time for API call '%s' on Thread with Id '%d'.\n", functionNameString, threadId);
    }

    // Create a new entry for this traced API call, and add it to the list for the current thread.
    DX12APIEntry* newEntry = new DX12APIEntry(threadId, inWrappedInterface, inFunctionId, inArguments, inReturnValue);
    currentThreadData->AddAPIEntry(currentThreadData->m_startTime, newEntry);

    return newEntry;
}

//--------------------------------------------------------------------------
/// Associate a set of CommandLists with the CommandQueue that they'll be executed through.
/// \param inCommandQueueWrapper A CommandQueue instance used to execute CommandLists.
/// \param inNumCommandLists The number of CommandLists in the incoming array.
/// \param inCommandLists An array of CommandLists to associate with the incoming CommandQueue.
//--------------------------------------------------------------------------
void DX12TraceAnalyzerLayer::TrackParentCommandQueue(GPS_ID3D12CommandQueue* inCommandQueueWrapper, UINT inNumCommandLists, GPS_ID3D12GraphicsCommandList* const* inCommandLists)
{
    CommandQueueToCommandListMap::iterator wrappedQueueIter = mCommandQueueTracker.find(inCommandQueueWrapper);

    if (wrappedQueueIter != mCommandQueueTracker.end())
    {
        // Already found it in the map. Add to the existing vector.
        WrappedCommandListSet& commandListVector = wrappedQueueIter->second;
        commandListVector.insert(inCommandLists, inCommandLists + inNumCommandLists);
    }
    else
    {
        // Not in the map yet- create a new vector and add these instances.
        ScopeLock commandQueueLocker(&mCommandQueueLockMutex);
        WrappedCommandListSet& commandListVector = mCommandQueueTracker[inCommandQueueWrapper];
        commandListVector.insert(inCommandLists, inCommandLists + inNumCommandLists);
    }
}

//--------------------------------------------------------------------------
/// Initialize the list of functions that we want to profile for GPU time.
/// Functions set to 'true' within this list be profiled and presented within the GPU trace.
//--------------------------------------------------------------------------
void DX12TraceAnalyzerLayer::SetProfiledFuncs()
{
    // Set the whole block of switches to false.
    memset(&mbProfiledFuncs, 0, sizeof(bool) * FuncId_MAX);

    // Draws
    mbProfiledFuncs[FuncId_ID3D12GraphicsCommandList_DrawInstanced] = true;
    mbProfiledFuncs[FuncId_ID3D12GraphicsCommandList_DrawIndexedInstanced] = true;

    // Compute
    mbProfiledFuncs[FuncId_ID3D12GraphicsCommandList_Dispatch] = true;

    // Copies
    mbProfiledFuncs[FuncId_ID3D12GraphicsCommandList_CopyBufferRegion] = true;
    mbProfiledFuncs[FuncId_ID3D12GraphicsCommandList_CopyTextureRegion] = true;
    mbProfiledFuncs[FuncId_ID3D12GraphicsCommandList_CopyResource] = true;

    // Execute
    mbProfiledFuncs[FuncId_ID3D12GraphicsCommandList_ExecuteBundle] = true;
    mbProfiledFuncs[FuncId_ID3D12GraphicsCommandList_ExecuteIndirect] = true;

    // Resolves
    mbProfiledFuncs[FuncId_ID3D12GraphicsCommandList_ResolveSubresource] = true;
    mbProfiledFuncs[FuncId_ID3D12GraphicsCommandList_ResolveQueryData] = true;

    // Clears
    mbProfiledFuncs[FuncId_ID3D12GraphicsCommandList_ClearRenderTargetView] = true;
    mbProfiledFuncs[FuncId_ID3D12GraphicsCommandList_ClearDepthStencilView] = true;
    mbProfiledFuncs[FuncId_ID3D12GraphicsCommandList_ClearUnorderedAccessViewUint] = true;
    mbProfiledFuncs[FuncId_ID3D12GraphicsCommandList_ClearUnorderedAccessViewFloat] = true;
}

//--------------------------------------------------------------------------
/// Return the stringified function name base don the input enum.
/// \param inFunctionId An enumeration representing the function being invoked.
/// \returns A string containing the function name.
//--------------------------------------------------------------------------
const char* DX12TraceAnalyzerLayer::GetFunctionNameFromId(FuncId inFunctionId)
{
    // The function name map is initialized when first traced.
    if (mFunctionIndexToNameString.empty())
    {
        // Included for cases where a non-profiled function is traced. Won't be visible within the client.
        mFunctionIndexToNameString[FuncId_UNDEFINED]                                                    = "UNDEFINED";

        mFunctionIndexToNameString[FuncId_IUnknown_QueryInterface]                                      = "QueryInterface";
        mFunctionIndexToNameString[FuncId_IUnknown_AddRef]                                              = "AddRef";
        mFunctionIndexToNameString[FuncId_IUnknown_Release]                                             = "Release";

        mFunctionIndexToNameString[FuncId_ID3D12Object_GetPrivateData]                                  = "GetPrivateData";
        mFunctionIndexToNameString[FuncId_ID3D12Object_SetPrivateData]                                  = "SetPrivateData";
        mFunctionIndexToNameString[FuncId_ID3D12Object_SetPrivateDataInterface]                         = "SetPrivateDataInterface";
        mFunctionIndexToNameString[FuncId_ID3D12Object_SetName]                                         = "SetName";

        mFunctionIndexToNameString[FuncId_ID3D12DeviceChild_GetDevice]                                  = "GetDevice";

        mFunctionIndexToNameString[FuncId_ID3D12Heap_GetDesc]                                           = "GetDesc";

        mFunctionIndexToNameString[FuncId_ID3D12RootSignatureDeserializer_GetRootSignatureDesc]         = "GetRootSignatureDesc";

        mFunctionIndexToNameString[FuncId_ID3D12Resource_Map]                                           = "Map";
        mFunctionIndexToNameString[FuncId_ID3D12Resource_Unmap]                                         = "Unmap";
        mFunctionIndexToNameString[FuncId_ID3D12Resource_GetDesc]                                       = "GetDesc";
        mFunctionIndexToNameString[FuncId_ID3D12Resource_GetGPUVirtualAddress]                          = "GetGPUVirtualAddress";
        mFunctionIndexToNameString[FuncId_ID3D12Resource_WriteToSubresource]                            = "WriteToSubresource";
        mFunctionIndexToNameString[FuncId_ID3D12Resource_ReadFromSubresource]                           = "ReadFromSubresource";
        mFunctionIndexToNameString[FuncId_ID3D12Resource_GetHeapProperties]                             = "GetHeapProperties";

        mFunctionIndexToNameString[FuncId_ID3D12CommandAllocator_Reset]                                 = "Reset";

        mFunctionIndexToNameString[FuncId_ID3D12Fence_GetCompletedValue]                                = "GetCompletedValue";
        mFunctionIndexToNameString[FuncId_ID3D12Fence_SetEventOnCompletion]                             = "SetEventOnCompletion";
        mFunctionIndexToNameString[FuncId_ID3D12Fence_Signal]                                           = "Signal";

        mFunctionIndexToNameString[FuncId_ID3D12PipelineState_GetCachedBlob]                            = "GetCachedBlob";

        mFunctionIndexToNameString[FuncId_ID3D12DescriptorHeap_GetDesc]                                 = "GetDesc";
        mFunctionIndexToNameString[FuncId_ID3D12DescriptorHeap_GetCPUDescriptorHandleForHeapStart]      = "GetCPUDescriptorHandleForHeapStart";
        mFunctionIndexToNameString[FuncId_ID3D12DescriptorHeap_GetGPUDescriptorHandleForHeapStart]      = "GetGPUDescriptorHandleForHeapStart";

        mFunctionIndexToNameString[FuncId_ID3D12CommandList_GetType]                                    = "GetType";

        mFunctionIndexToNameString[FuncId_ID3D12GraphicsCommandList_Close]                              = "Close";
        mFunctionIndexToNameString[FuncId_ID3D12GraphicsCommandList_Reset]                              = "Reset";
        mFunctionIndexToNameString[FuncId_ID3D12GraphicsCommandList_ClearState]                         = "ClearState";
        mFunctionIndexToNameString[FuncId_ID3D12GraphicsCommandList_DrawInstanced]                      = "DrawInstanced";
        mFunctionIndexToNameString[FuncId_ID3D12GraphicsCommandList_DrawIndexedInstanced]               = "DrawIndexedInstanced";
        mFunctionIndexToNameString[FuncId_ID3D12GraphicsCommandList_Dispatch]                           = "Dispatch";
        mFunctionIndexToNameString[FuncId_ID3D12GraphicsCommandList_CopyBufferRegion]                   = "CopyBufferRegion";
        mFunctionIndexToNameString[FuncId_ID3D12GraphicsCommandList_CopyTextureRegion]                  = "CopyTextureRegion";
        mFunctionIndexToNameString[FuncId_ID3D12GraphicsCommandList_CopyResource]                       = "CopyResource";
        mFunctionIndexToNameString[FuncId_ID3D12GraphicsCommandList_CopyTiles]                          = "CopyTiles";
        mFunctionIndexToNameString[FuncId_ID3D12GraphicsCommandList_ResolveSubresource]                 = "ResolveSubresource";
        mFunctionIndexToNameString[FuncId_ID3D12GraphicsCommandList_IASetPrimitiveTopology]             = "IASetPrimitiveTopology";
        mFunctionIndexToNameString[FuncId_ID3D12GraphicsCommandList_RSSetViewports]                     = "RSSetViewports";
        mFunctionIndexToNameString[FuncId_ID3D12GraphicsCommandList_RSSetScissorRects]                  = "RSSetScissorRects";
        mFunctionIndexToNameString[FuncId_ID3D12GraphicsCommandList_OMSetBlendFactor]                   = "OMSetBlendFactor";
        mFunctionIndexToNameString[FuncId_ID3D12GraphicsCommandList_OMSetStencilRef]                    = "OMSetStencilRef";
        mFunctionIndexToNameString[FuncId_ID3D12GraphicsCommandList_SetPipelineState]                   = "SetPipelineState";
        mFunctionIndexToNameString[FuncId_ID3D12GraphicsCommandList_ResourceBarrier]                    = "ResourceBarrier";
        mFunctionIndexToNameString[FuncId_ID3D12GraphicsCommandList_ExecuteBundle]                      = "ExecuteBundle";
        mFunctionIndexToNameString[FuncId_ID3D12GraphicsCommandList_SetDescriptorHeaps]                 = "SetDescriptorHeaps";
        mFunctionIndexToNameString[FuncId_ID3D12GraphicsCommandList_SetComputeRootSignature]            = "SetComputeRootSignature";
        mFunctionIndexToNameString[FuncId_ID3D12GraphicsCommandList_SetGraphicsRootSignature]           = "SetGraphicsRootSignature";
        mFunctionIndexToNameString[FuncId_ID3D12GraphicsCommandList_SetComputeRootDescriptorTable]      = "SetComputeRootDescriptorTable";
        mFunctionIndexToNameString[FuncId_ID3D12GraphicsCommandList_SetGraphicsRootDescriptorTable]     = "SetGraphicsRootDescriptorTable";
        mFunctionIndexToNameString[FuncId_ID3D12GraphicsCommandList_SetComputeRoot32BitConstant]        = "SetComputeRoot32BitConstant";
        mFunctionIndexToNameString[FuncId_ID3D12GraphicsCommandList_SetGraphicsRoot32BitConstant]       = "SetGraphicsRoot32BitConstant";
        mFunctionIndexToNameString[FuncId_ID3D12GraphicsCommandList_SetComputeRoot32BitConstants]       = "SetComputeRoot32BitConstants";
        mFunctionIndexToNameString[FuncId_ID3D12GraphicsCommandList_SetGraphicsRoot32BitConstants]      = "SetGraphicsRoot32BitConstants";
        mFunctionIndexToNameString[FuncId_ID3D12GraphicsCommandList_SetComputeRootConstantBufferView]   = "SetComputeRootConstantBufferView";
        mFunctionIndexToNameString[FuncId_ID3D12GraphicsCommandList_SetGraphicsRootConstantBufferView]  = "SetGraphicsRootConstantBufferView";
        mFunctionIndexToNameString[FuncId_ID3D12GraphicsCommandList_SetComputeRootShaderResourceView]   = "SetComputeRootShaderResourceView";
        mFunctionIndexToNameString[FuncId_ID3D12GraphicsCommandList_SetGraphicsRootShaderResourceView]  = "SetGraphicsRootShaderResourceView";
        mFunctionIndexToNameString[FuncId_ID3D12GraphicsCommandList_SetComputeRootUnorderedAccessView]  = "SetComputeRootUnorderedAccessView";
        mFunctionIndexToNameString[FuncId_ID3D12GraphicsCommandList_SetGraphicsRootUnorderedAccessView] = "SetGraphicsRootUnorderedAccessView";
        mFunctionIndexToNameString[FuncId_ID3D12GraphicsCommandList_IASetIndexBuffer]                   = "IASetIndexBuffer";
        mFunctionIndexToNameString[FuncId_ID3D12GraphicsCommandList_IASetVertexBuffers]                 = "IASetVertexBuffers";
        mFunctionIndexToNameString[FuncId_ID3D12GraphicsCommandList_SOSetTargets]                       = "SOSetTargets";
        mFunctionIndexToNameString[FuncId_ID3D12GraphicsCommandList_OMSetRenderTargets]                 = "OMSetRenderTargets";
        mFunctionIndexToNameString[FuncId_ID3D12GraphicsCommandList_ClearDepthStencilView]              = "ClearDepthStencilView";
        mFunctionIndexToNameString[FuncId_ID3D12GraphicsCommandList_ClearRenderTargetView]              = "ClearRenderTargetView";
        mFunctionIndexToNameString[FuncId_ID3D12GraphicsCommandList_ClearUnorderedAccessViewUint]       = "ClearUnorderedAccessViewUint";
        mFunctionIndexToNameString[FuncId_ID3D12GraphicsCommandList_ClearUnorderedAccessViewFloat]      = "ClearUnorderedAccessViewFloat";
        mFunctionIndexToNameString[FuncId_ID3D12GraphicsCommandList_DiscardResource]                    = "DiscardResource";
        mFunctionIndexToNameString[FuncId_ID3D12GraphicsCommandList_BeginQuery]                         = "BeginQuery";
        mFunctionIndexToNameString[FuncId_ID3D12GraphicsCommandList_EndQuery]                           = "EndQuery";
        mFunctionIndexToNameString[FuncId_ID3D12GraphicsCommandList_ResolveQueryData]                   = "ResolveQueryData";
        mFunctionIndexToNameString[FuncId_ID3D12GraphicsCommandList_SetPredication]                     = "SetPredication";
        mFunctionIndexToNameString[FuncId_ID3D12GraphicsCommandList_SetMarker]                          = "SetMarker";
        mFunctionIndexToNameString[FuncId_ID3D12GraphicsCommandList_BeginEvent]                         = "BeginEvent";
        mFunctionIndexToNameString[FuncId_ID3D12GraphicsCommandList_EndEvent]                           = "EndEvent";
        mFunctionIndexToNameString[FuncId_ID3D12GraphicsCommandList_ExecuteIndirect]                    = "ExecuteIndirect";

        mFunctionIndexToNameString[FuncId_ID3D12CommandQueue_UpdateTileMappings]                        = "UpdateTileMappings";
        mFunctionIndexToNameString[FuncId_ID3D12CommandQueue_CopyTileMappings]                          = "CopyTileMappings";
        mFunctionIndexToNameString[FuncId_ID3D12CommandQueue_ExecuteCommandLists]                       = "ExecuteCommandLists";
        mFunctionIndexToNameString[FuncId_ID3D12CommandQueue_SetMarker]                                 = "SetMarker";
        mFunctionIndexToNameString[FuncId_ID3D12CommandQueue_BeginEvent]                                = "BeginEvent";
        mFunctionIndexToNameString[FuncId_ID3D12CommandQueue_EndEvent]                                  = "EndEvent";
        mFunctionIndexToNameString[FuncId_ID3D12CommandQueue_Signal]                                    = "Signal";
        mFunctionIndexToNameString[FuncId_ID3D12CommandQueue_Wait]                                      = "Wait";
        mFunctionIndexToNameString[FuncId_ID3D12CommandQueue_GetTimestampFrequency]                     = "GetTimestampFrequency";
        mFunctionIndexToNameString[FuncId_ID3D12CommandQueue_GetClockCalibration]                       = "GetClockCalibration";
        mFunctionIndexToNameString[FuncId_ID3D12CommandQueue_GetDesc]                                   = "GetDesc";

        mFunctionIndexToNameString[FuncId_ID3D12Device_GetNodeCount]                                    = "GetNodeCount";
        mFunctionIndexToNameString[FuncId_ID3D12Device_CreateCommandQueue]                              = "CreateCommandQueue";
        mFunctionIndexToNameString[FuncId_ID3D12Device_CreateCommandAllocator]                          = "CreateCommandAllocator";
        mFunctionIndexToNameString[FuncId_ID3D12Device_CreateGraphicsPipelineState]                     = "CreateGraphicsPipelineState";
        mFunctionIndexToNameString[FuncId_ID3D12Device_CreateComputePipelineState]                      = "CreateComputePipelineState";
        mFunctionIndexToNameString[FuncId_ID3D12Device_CreateCommandList]                               = "CreateCommandList";
        mFunctionIndexToNameString[FuncId_ID3D12Device_CheckFeatureSupport]                             = "CheckFeatureSupport";
        mFunctionIndexToNameString[FuncId_ID3D12Device_CreateDescriptorHeap]                            = "CreateDescriptorHeap";
        mFunctionIndexToNameString[FuncId_ID3D12Device_GetDescriptorHandleIncrementSize]                = "GetDescriptorHandleIncrementSize";
        mFunctionIndexToNameString[FuncId_ID3D12Device_CreateRootSignature]                             = "CreateRootSignature";
        mFunctionIndexToNameString[FuncId_ID3D12Device_CreateConstantBufferView]                        = "CreateConstantBufferView";
        mFunctionIndexToNameString[FuncId_ID3D12Device_CreateShaderResourceView]                        = "CreateShaderResourceView";
        mFunctionIndexToNameString[FuncId_ID3D12Device_CreateUnorderedAccessView]                       = "CreateUnorderedAccessView";
        mFunctionIndexToNameString[FuncId_ID3D12Device_CreateRenderTargetView]                          = "CreateRenderTargetView";
        mFunctionIndexToNameString[FuncId_ID3D12Device_CreateDepthStencilView]                          = "CreateDepthStencilView";
        mFunctionIndexToNameString[FuncId_ID3D12Device_CreateSampler]                                   = "CreateSampler";
        mFunctionIndexToNameString[FuncId_ID3D12Device_CopyDescriptors]                                 = "CopyDescriptors";
        mFunctionIndexToNameString[FuncId_ID3D12Device_CopyDescriptorsSimple]                           = "CopyDescriptorsSimple";
        mFunctionIndexToNameString[FuncId_ID3D12Device_GetResourceAllocationInfo]                       = "GetResourceAllocationInfo";
        mFunctionIndexToNameString[FuncId_ID3D12Device_GetCustomHeapProperties]                         = "GetCustomHeapProperties";
        mFunctionIndexToNameString[FuncId_ID3D12Device_CreateCommittedResource]                         = "CreateCommittedResource";
        mFunctionIndexToNameString[FuncId_ID3D12Device_CreateHeap]                                      = "CreateHeap";
        mFunctionIndexToNameString[FuncId_ID3D12Device_CreatePlacedResource]                            = "CreatePlacedResource";
        mFunctionIndexToNameString[FuncId_ID3D12Device_CreateReservedResource]                          = "CreateReservedResource";
        mFunctionIndexToNameString[FuncId_ID3D12Device_CreateSharedHandle]                              = "CreateSharedHandle";
        mFunctionIndexToNameString[FuncId_ID3D12Device_OpenSharedHandle]                                = "OpenSharedHandle";
        mFunctionIndexToNameString[FuncId_ID3D12Device_OpenSharedHandleByName]                          = "OpenSharedHandleByName";
        mFunctionIndexToNameString[FuncId_ID3D12Device_MakeResident]                                    = "MakeResident";
        mFunctionIndexToNameString[FuncId_ID3D12Device_Evict]                                           = "Evict";
        mFunctionIndexToNameString[FuncId_ID3D12Device_CreateFence]                                     = "CreateFence";
        mFunctionIndexToNameString[FuncId_ID3D12Device_GetDeviceRemovedReason]                          = "GetDeviceRemovedReason";
        mFunctionIndexToNameString[FuncId_ID3D12Device_GetCopyableFootprints]                           = "GetCopyableFootprints";
        mFunctionIndexToNameString[FuncId_ID3D12Device_CreateQueryHeap]                                 = "CreateQueryHeap";
        mFunctionIndexToNameString[FuncId_ID3D12Device_SetStablePowerState]                             = "SetStablePowerState";
        mFunctionIndexToNameString[FuncId_ID3D12Device_CreateCommandSignature]                          = "CreateCommandSignature";
        mFunctionIndexToNameString[FuncId_ID3D12Device_GetResourceTiling]                               = "GetResourceTiling";
        mFunctionIndexToNameString[FuncId_ID3D12Device_GetAdapterLuid]                                  = "GetAdapterLuid";
    }

    FuncIdToNamestringMap::const_iterator funcIter = mFunctionIndexToNameString.find(inFunctionId);
    FuncIdToNamestringMap::const_iterator endIter = mFunctionIndexToNameString.end();

    if (funcIter != endIter)
    {
        return (funcIter->second).c_str();
    }

    Log(logERROR, "Failed to stringify FuncId '%d'\n", inFunctionId);

    // Throw up a warning for development in case this list needs to get updated.
    PsAssert(funcIter != endIter);
    return "UNDEFINED";
}

//--------------------------------------------------------------------------
/// Retrieve the API Type that an API call has been classified into.
/// \param inAPIFuncId The FunctionId of an API call to retrieve the group for.
/// \returns An API Type that a call has been classified as being part of.
//--------------------------------------------------------------------------
eAPIType DX12TraceAnalyzerLayer::GetAPIGroupFromAPI(FuncId inAPIFuncId) const
{
    eAPIType apiType = kAPIType_Unknown;

    switch (inAPIFuncId)
    {
        case FuncId_ID3D12GraphicsCommandList_SetDescriptorHeaps:
        case FuncId_ID3D12GraphicsCommandList_SetComputeRootSignature:
        case FuncId_ID3D12GraphicsCommandList_SetGraphicsRootSignature:
        case FuncId_ID3D12GraphicsCommandList_SetComputeRootDescriptorTable:
        case FuncId_ID3D12GraphicsCommandList_SetGraphicsRootDescriptorTable:
        case FuncId_ID3D12GraphicsCommandList_SetComputeRoot32BitConstant:
        case FuncId_ID3D12GraphicsCommandList_SetGraphicsRoot32BitConstant:
        case FuncId_ID3D12GraphicsCommandList_SetComputeRoot32BitConstants:
        case FuncId_ID3D12GraphicsCommandList_SetGraphicsRoot32BitConstants:
        case FuncId_ID3D12GraphicsCommandList_SetComputeRootConstantBufferView:
        case FuncId_ID3D12GraphicsCommandList_SetGraphicsRootConstantBufferView:
        case FuncId_ID3D12GraphicsCommandList_SetComputeRootShaderResourceView:
        case FuncId_ID3D12GraphicsCommandList_SetGraphicsRootShaderResourceView:
        case FuncId_ID3D12GraphicsCommandList_SetComputeRootUnorderedAccessView:
        case FuncId_ID3D12GraphicsCommandList_SetGraphicsRootUnorderedAccessView:
            apiType = kAPIType_BindingCommand;
            break;

        case FuncId_ID3D12GraphicsCommandList_ClearState:
        case FuncId_ID3D12GraphicsCommandList_ClearDepthStencilView:
        case FuncId_ID3D12GraphicsCommandList_ClearRenderTargetView:
        case FuncId_ID3D12GraphicsCommandList_ClearUnorderedAccessViewUint:
        case FuncId_ID3D12GraphicsCommandList_ClearUnorderedAccessViewFloat:
            apiType = kAPIType_ClearCommand;
            break;

        case FuncId_ID3D12GraphicsCommandList_Close:
        case FuncId_ID3D12GraphicsCommandList_Reset:
        case FuncId_ID3D12GraphicsCommandList_ResolveSubresource:
        case FuncId_ID3D12GraphicsCommandList_SetPipelineState:
        case FuncId_ID3D12GraphicsCommandList_ExecuteBundle:
        case FuncId_ID3D12GraphicsCommandList_DiscardResource:
        case FuncId_ID3D12GraphicsCommandList_BeginQuery:
        case FuncId_ID3D12GraphicsCommandList_EndQuery:
        case FuncId_ID3D12GraphicsCommandList_ResolveQueryData:
        case FuncId_ID3D12GraphicsCommandList_SetPredication:
        case FuncId_ID3D12GraphicsCommandList_ExecuteIndirect:
            apiType = kAPIType_Command;
            break;

        case FuncId_ID3D12CommandQueue_CopyTileMappings:
        case FuncId_ID3D12Device_CopyDescriptors:
        case FuncId_ID3D12Device_CopyDescriptorsSimple:
            apiType = kAPIType_Copy;
            break;

        case FuncId_ID3D12Device_CreateCommandQueue:
        case FuncId_ID3D12Device_CreateCommandAllocator:
        case FuncId_ID3D12Device_CreateGraphicsPipelineState:
        case FuncId_ID3D12Device_CreateComputePipelineState:
        case FuncId_ID3D12Device_CreateCommandList:
        case FuncId_ID3D12Device_CreateDescriptorHeap:
        case FuncId_ID3D12Device_CreateRootSignature:
        case FuncId_ID3D12Device_CreateConstantBufferView:
        case FuncId_ID3D12Device_CreateShaderResourceView:
        case FuncId_ID3D12Device_CreateUnorderedAccessView:
        case FuncId_ID3D12Device_CreateRenderTargetView:
        case FuncId_ID3D12Device_CreateDepthStencilView:
        case FuncId_ID3D12Device_CreateSampler:
        case FuncId_ID3D12Device_CreateHeap:
        case FuncId_ID3D12Device_CreatePlacedResource:
        case FuncId_ID3D12Device_CreateReservedResource:
        case FuncId_ID3D12Device_CreateSharedHandle:
        case FuncId_ID3D12Device_CreateFence:
        case FuncId_ID3D12Device_CreateQueryHeap:
        case FuncId_ID3D12Device_CreateCommandSignature:
            apiType = kAPIType_Create;
            break;

        case FuncId_ID3D12Object_GetPrivateData:
        case FuncId_ID3D12Object_SetPrivateData:
        case FuncId_ID3D12Object_SetPrivateDataInterface:
        case FuncId_ID3D12Object_SetName:
        case FuncId_ID3D12GraphicsCommandList_SetMarker:
        case FuncId_ID3D12GraphicsCommandList_BeginEvent:
        case FuncId_ID3D12GraphicsCommandList_EndEvent:
        case FuncId_ID3D12CommandQueue_BeginEvent:
        case FuncId_ID3D12CommandQueue_EndEvent:
        case FuncId_ID3D12CommandQueue_SetMarker:
            apiType = kAPIType_Debug;
            break;

        case FuncId_ID3D12GraphicsCommandList_DrawInstanced:
        case FuncId_ID3D12GraphicsCommandList_DrawIndexedInstanced:
        case FuncId_ID3D12GraphicsCommandList_Dispatch:
            apiType = kAPIType_DrawCommand;
            break;

        case FuncId_IUnknown_QueryInterface:
        case FuncId_IUnknown_AddRef:
        case FuncId_IUnknown_Release:
        case FuncId_ID3D12DeviceChild_GetDevice:
        case FuncId_ID3D12Heap_GetDesc:
        case FuncId_ID3D12RootSignatureDeserializer_GetRootSignatureDesc:
        case FuncId_ID3D12Resource_GetHeapProperties:
        case FuncId_ID3D12CommandAllocator_Reset:
        case FuncId_ID3D12PipelineState_GetCachedBlob:
        case FuncId_ID3D12DescriptorHeap_GetDesc:
        case FuncId_ID3D12DescriptorHeap_GetCPUDescriptorHandleForHeapStart:
        case FuncId_ID3D12DescriptorHeap_GetGPUDescriptorHandleForHeapStart:
        case FuncId_ID3D12CommandList_GetType:
        case FuncId_ID3D12CommandQueue_ExecuteCommandLists:
        case FuncId_ID3D12CommandQueue_GetTimestampFrequency:
        case FuncId_ID3D12CommandQueue_GetClockCalibration:
        case FuncId_ID3D12CommandQueue_GetDesc:
        case FuncId_ID3D12Device_GetNodeCount:
        case FuncId_ID3D12Device_CheckFeatureSupport:
        case FuncId_ID3D12Device_GetDescriptorHandleIncrementSize:
        case FuncId_ID3D12Device_GetResourceAllocationInfo:
        case FuncId_ID3D12Device_GetCustomHeapProperties:
        case FuncId_ID3D12Device_OpenSharedHandle:
        case FuncId_ID3D12Device_OpenSharedHandleByName:
        case FuncId_ID3D12Device_GetDeviceRemovedReason:
        case FuncId_ID3D12Device_GetCopyableFootprints:
        case FuncId_ID3D12Device_SetStablePowerState:
        case FuncId_ID3D12Device_GetResourceTiling:
        case FuncId_ID3D12Device_GetAdapterLuid:
            apiType = kAPIType_General;
            break;

        case FuncId_ID3D12CommandQueue_UpdateTileMappings:
        case FuncId_ID3D12Device_MakeResident:
        case FuncId_ID3D12Device_Evict:
            apiType = kAPIType_Paging;
            break;

        case FuncId_ID3D12Resource_Map:
        case FuncId_ID3D12Resource_Unmap:
        case FuncId_ID3D12Resource_GetDesc:
        case FuncId_ID3D12Resource_GetGPUVirtualAddress:
        case FuncId_ID3D12Resource_ReadFromSubresource:
            apiType = kAPIType_Resource;
            break;

        case FuncId_ID3D12GraphicsCommandList_IASetPrimitiveTopology:
        case FuncId_ID3D12GraphicsCommandList_RSSetViewports:
        case FuncId_ID3D12GraphicsCommandList_RSSetScissorRects:
        case FuncId_ID3D12GraphicsCommandList_OMSetBlendFactor:
        case FuncId_ID3D12GraphicsCommandList_OMSetStencilRef:
        case FuncId_ID3D12GraphicsCommandList_IASetIndexBuffer:
        case FuncId_ID3D12GraphicsCommandList_IASetVertexBuffers:
        case FuncId_ID3D12GraphicsCommandList_SOSetTargets:
        case FuncId_ID3D12GraphicsCommandList_OMSetRenderTargets:
            apiType = kAPIType_StageCommand;
            break;

        case FuncId_ID3D12Fence_GetCompletedValue:
        case FuncId_ID3D12Fence_SetEventOnCompletion:
        case FuncId_ID3D12Fence_Signal:
        case FuncId_ID3D12GraphicsCommandList_ResourceBarrier:
        case FuncId_ID3D12CommandQueue_Signal:
        case FuncId_ID3D12CommandQueue_Wait:
            apiType = kAPIType_Synchronization;
            break;


        default:
            apiType = kAPIType_Unknown;
    }

    return apiType;
}

//--------------------------------------------------------------------------
/// Create a new map to associate a LinkId with profiling results.
/// \param inQueueType The Queue that was submitted to retrieve profiling results.
/// \returns A newly-created/retrieved map to store profiling results in.
//--------------------------------------------------------------------------
SampleIdToProfilerResultMap* DX12TraceAnalyzerLayer::FindOrCreateProfilerResultsMap(GPS_ID3D12CommandQueue* pWrappedQueue)
{
    SampleIdToProfilerResultMap* pResultMap = nullptr;

    if (mEntriesWithProfilingResults.count(pWrappedQueue) == 0)
    {
        // Lock before we insert something new into this map.
        ScopeLock profilerResultsLock(&mProfilingResultsMutex);

        // Insert the new map into our results structure.
        pResultMap = new SampleIdToProfilerResultMap();
        mEntriesWithProfilingResults[pWrappedQueue] = pResultMap;
    }
    else
    {
        pResultMap = mEntriesWithProfilingResults[pWrappedQueue];
    }

    return pResultMap;
}

//--------------------------------------------------------------------------
/// Store results obtained from the DX12CmdListProfiler.
/// \param pQueue The Queue that the profiled calls were executed through.
/// \param inProfilerResults The set of results collected after executed profiled commands.
//--------------------------------------------------------------------------
void DX12TraceAnalyzerLayer::StoreProfilerResults(GPS_ID3D12CommandQueue* pWrappedQueue, const std::vector<ProfilerResult>& inProfilerResults)
{
    SampleIdToProfilerResultMap* pResultMap = FindOrCreateProfilerResultsMap(pWrappedQueue);
    PsAssert(pResultMap != NULL);

    if (pResultMap != NULL)
    {
        for (size_t resultIndex = 0; resultIndex < inProfilerResults.size(); ++resultIndex)
        {
            const ProfilerResult& currentResult = inProfilerResults[resultIndex];
            const UINT64 linkId = currentResult.measurementInfo.idInfo.sampleId;

            // Where does this come from? Is it a copy? Should it be a new ProfilerResult?
            ProfilerResult* pNewResult = new ProfilerResult;

            CopyProfilerResult(pNewResult, &currentResult);

            // Store the new result in the result map.
            (*pResultMap)[linkId] = pNewResult;
        }
    }
}

//--------------------------------------------------------------------------
/// Clear out all of the ProfilerResults collected by the MantleProfiler.
//--------------------------------------------------------------------------
void DX12TraceAnalyzerLayer::ClearProfilingResults()
{
#if USE_GPA_PROFILING == 0
    ScopeLock resultsLock(&mProfilingResultsMutex);

    QueueWrapperToProfilingResultsMap::iterator itemIter;
    QueueWrapperToProfilingResultsMap::iterator beginIter = mEntriesWithProfilingResults.begin();
    QueueWrapperToProfilingResultsMap::iterator endIter = mEntriesWithProfilingResults.end();

    // Kill the map associated with each Queue type.
    for (itemIter = beginIter; itemIter != endIter; ++itemIter)
    {
        SampleIdToProfilerResultMap* pResultMap = itemIter->second;

        SampleIdToProfilerResultMap::iterator resultIter;
        SampleIdToProfilerResultMap::iterator resultBegin = pResultMap->begin();
        SampleIdToProfilerResultMap::iterator resultEnd = pResultMap->end();

        for (resultIter = resultBegin; resultIter != resultEnd; ++resultIter)
        {
            SAFE_DELETE(resultIter->second);
        }

        SAFE_DELETE(pResultMap);
    }

    // It should be safe to kill this now that all of the entries are destroyed.
    mEntriesWithProfilingResults.clear();
#endif

    mSampleIdToEntry.clear();
    mCommandListToSampleId.clear();
}

//--------------------------------------------------------------------------
/// Opens a GPA context for the specified command list and initializes it for counter collection
/// \param pCommandList the command list to use to open a GPA context
//--------------------------------------------------------------------------
void DX12TraceAnalyzerLayer::OpenAndInitializeGPAContext(const ID3D12GraphicsCommandList* const pCommandList)
{
    DX12Interceptor* dx12Interceptor = static_cast<DX12Interceptor*>(GetInterceptor());

	GPUPerfAPILoader& gpaLoader = dx12Interceptor->GetGPALoader();

    GPA_Status openStatus = gpaLoader.GPA_OpenContext((void*)pCommandList);

    if (openStatus != GPA_STATUS_OK)
    {
        Log(logERROR, "Failed to open GPA Context for command list '0x%p'. GPA_Status: '%d'.\n", pCommandList, openStatus);
    }
    else
    {
        gpa_uint32 preBottomCounterIndex;
        gpa_uint32 postBottomCounterIndex;
        GPA_Status counterPreIndexStatus = gpaLoader.GPA_GetCounterIndex("PreBottomTimestamp", &preBottomCounterIndex);
        GPA_Status counterPostIndexStatus = gpaLoader.GPA_GetCounterIndex("PostBottomTimestamp", &postBottomCounterIndex);

        if (counterPreIndexStatus == GPA_STATUS_OK && counterPostIndexStatus == GPA_STATUS_OK)
        {
            GPA_Status preBottomStatus = GPA_STATUS_OK;
            GPA_Status postBottomStatus = GPA_STATUS_OK;

            if (gpaLoader.GPA_IsCounterEnabled(preBottomCounterIndex) != GPA_STATUS_OK)
            {
                preBottomStatus = gpaLoader.GPA_EnableCounter(preBottomCounterIndex);
            }

            if (gpaLoader.GPA_IsCounterEnabled(postBottomCounterIndex) != GPA_STATUS_OK)
            {
                postBottomStatus = gpaLoader.GPA_EnableCounter(postBottomCounterIndex);
            }

            if (preBottomStatus == GPA_STATUS_OK && postBottomStatus == GPA_STATUS_OK)
            {
                GPA_Status beginSessionStatus = gpaLoader.GPA_BeginSession(&mCurrentSessionId);

                if (beginSessionStatus == GPA_STATUS_OK)
                {
                    GPA_Status passStatus = gpaLoader.GPA_BeginPass();

                    if (passStatus != GPA_STATUS_OK)
                    {
                        Log(logERROR, "Failed to start GPA PASS. Error code: '%d'.\n", passStatus);
                    }
                }
                else
                {
                    Log(logERROR, "Failed to start GPA session. Error code: '%d'.\n", beginSessionStatus);
                }
            }
            else
            {
                Log(logERROR, "Failed to enable GPU Time collection. Error codes: '%d' and '%d'.\n", preBottomStatus, postBottomStatus);
            }
        }
        else
        {
            Log(logERROR, "Failed to retrieve counter indices: '%d' and '%d'.\n", counterPreIndexStatus, counterPostIndexStatus);
        }
    }
}

//--------------------------------------------------------------------------
/// Associates the specified sample id with the specified command list
/// \param pCommandList the command list with which to associate the sampleId
/// \param sampleId the sample id to associate with the specified command list
//--------------------------------------------------------------------------
void DX12TraceAnalyzerLayer::AddSampleToCommandList(const ID3D12GraphicsCommandList* const pCommandList, gpa_uint32 sampleId)
{
    if (mCommandListToSampleId.count(pCommandList) > 0)
    {
        mCommandListToSampleId[pCommandList].push_back(sampleId);
    }
    else
    {
        std::vector<gpa_uint32> commandListSamples;
        commandListSamples.push_back(sampleId);
        mCommandListToSampleId[pCommandList] = commandListSamples;
    }
}

//--------------------------------------------------------------------------
/// Checks whether the specified sampleId is associated with the specified commandList
/// \param pCommandList the command list to check
/// \param sampleId the sample id to check
/// \return true if the sample id is associated with the command list
//--------------------------------------------------------------------------
bool DX12TraceAnalyzerLayer::CommandListContainsSample(const ID3D12GraphicsCommandList* const pCommandList, gpa_uint32 sampleId)
{
    bool retVal = false;

    if (mCommandListToSampleId.count(pCommandList) > 0)
    {
        std::vector<gpa_uint32> commandListSamples = mCommandListToSampleId[pCommandList];
        retVal = std::find(commandListSamples.begin(), commandListSamples.end(), sampleId) != commandListSamples.end();
    }

    return retVal;
}

//--------------------------------------------------------------------------
/// Given a SampleId, find the DX12APIEntry that was logged while API tracing.
/// \param inSampleId The SampleId to search with.
/// \return The buffered DX12APIEntry with a matching SampleId, or NULL if it doesn't exist for some reason.
//--------------------------------------------------------------------------
DX12APIEntry* DX12TraceAnalyzerLayer::FindInvocationBySampleId(UINT64 inSampleId)
{
    ScopeLock mapInsertionLock(&mTraceMutex);

    DX12APIEntry* pSearchResult = NULL;

    // Look within each traced thread for the given SampleId.
    std::map<DWORD, ThreadTraceData*>::const_iterator traceIter;

    for (traceIter = mThreadTraces.begin(); traceIter != mThreadTraces.end(); ++traceIter)
    {
        DX12ThreadTraceData* pThreadTrace = static_cast<DX12ThreadTraceData*>(traceIter->second);
        pSearchResult = pThreadTrace->FindInvocationBySampleId(inSampleId);

        if (pSearchResult != NULL)
        {
            break;   // We found it, let's get moving.
        }
    }

    PsAssert(pSearchResult != NULL);

    return pSearchResult;
}